# Prompt 04: Strategy Engine

## Purpose

Build the complete strategy execution framework that powers Flowrex's trading logic. This system supports multiple concurrent strategies (NBB, JadeCap, Fabio, Tori), generates trading signals, manages positions, and enforces per-strategy risk parameters.

## Scope

- Base Strategy class with common interface
- Signal generation and storage
- Position tracking and management
- Four complete strategy implementations:
  - **NBB (No Bullshit Breaker)**: Supply/demand zone breakouts
  - **JadeCap**: Multi-timeframe trend following
  - **Fabio**: Auction Market Theory (AMT) with POC/VAH/VAL
  - **Tori**: Trendline + Fibonacci confluence
- Strategy configuration and parameters
- Signal validation and filtering
- API routes for strategy management
- Comprehensive test suite

## Strategy Architecture

```
Market Data (from Data Engine)
    ↓
Strategy Manager → [NBB, JadeCap, Fabio, Tori]
    ↓
Signal Generator → Signal Validator → Signal Storage
    ↓
Position Manager → Risk Engine (Prompt 09)
    ↓
Execution Engine (Prompt 10)
```

## Implementation

### Step 1: Database Models

Create `backend/app/models/signal.py`:

```python
from sqlalchemy import String, Float, Integer, Boolean, Enum as SQLEnum, ForeignKey, Index
from sqlalchemy.orm import Mapped, mapped_column, relationship
from datetime import datetime
from typing import Optional
import enum
from app.models.base import Base, TimestampMixin


class SignalType(str, enum.Enum):
    LONG = "long"
    SHORT = "short"


class SignalStatus(str, enum.Enum):
    PENDING = "pending"
    ACTIVE = "active"
    EXECUTED = "executed"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class Signal(Base, TimestampMixin):
    """Trading signal generated by a strategy."""
    __tablename__ = "signals"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    strategy_name: Mapped[str] = mapped_column(String(50), nullable=False, index=True)
    symbol: Mapped[str] = mapped_column(String(20), nullable=False, index=True)
    signal_type: Mapped[SignalType] = mapped_column(SQLEnum(SignalType), nullable=False)
    status: Mapped[SignalStatus] = mapped_column(
        SQLEnum(SignalStatus),
        default=SignalStatus.PENDING,
        nullable=False,
        index=True
    )

    # Entry parameters
    entry_price: Mapped[float] = mapped_column(Float, nullable=False)
    stop_loss: Mapped[float] = mapped_column(Float, nullable=False)
    take_profit: Mapped[float] = mapped_column(Float, nullable=False)

    # Position sizing
    risk_percent: Mapped[float] = mapped_column(Float, nullable=False)  # % of account
    position_size: Mapped[Optional[float]] = mapped_column(Float, nullable=True)  # lots/shares

    # Metadata
    timeframe: Mapped[str] = mapped_column(String(10), nullable=False)
    confidence: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)  # 0-100
    reason: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)

    # Timestamps
    signal_time: Mapped[datetime] = mapped_column(nullable=False, index=True)
    expiry_time: Mapped[Optional[datetime]] = mapped_column(nullable=True)
    executed_at: Mapped[Optional[datetime]] = mapped_column(nullable=True)

    # Relationships
    position_id: Mapped[Optional[int]] = mapped_column(ForeignKey("positions.id"), nullable=True)
    position: Mapped[Optional["Position"]] = relationship("Position", back_populates="signal")

    __table_args__ = (
        Index("ix_signal_strategy_status", "strategy_name", "status"),
        Index("ix_signal_symbol_status", "symbol", "status"),
    )

    def __repr__(self) -> str:
        return f"<Signal {self.id} {self.strategy_name} {self.signal_type.value} {self.symbol} @ {self.entry_price}>"

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward ratio."""
        if self.signal_type == SignalType.LONG:
            risk = self.entry_price - self.stop_loss
            reward = self.take_profit - self.entry_price
        else:
            risk = self.stop_loss - self.entry_price
            reward = self.entry_price - self.take_profit

        return reward / risk if risk > 0 else 0.0
```

Create `backend/app/models/position.py`:

```python
from sqlalchemy import String, Float, Integer, Enum as SQLEnum, Index
from sqlalchemy.orm import Mapped, mapped_column, relationship
from datetime import datetime
from typing import Optional, List
import enum
from app.models.base import Base, TimestampMixin


class PositionStatus(str, enum.Enum):
    OPEN = "open"
    CLOSED = "closed"
    PARTIAL = "partial"


class PositionSide(str, enum.Enum):
    LONG = "long"
    SHORT = "short"


class Position(Base, TimestampMixin):
    """Active or historical trading position."""
    __tablename__ = "positions"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    strategy_name: Mapped[str] = mapped_column(String(50), nullable=False, index=True)
    symbol: Mapped[str] = mapped_column(String(20), nullable=False, index=True)
    side: Mapped[PositionSide] = mapped_column(SQLEnum(PositionSide), nullable=False)
    status: Mapped[PositionStatus] = mapped_column(
        SQLEnum(PositionStatus),
        default=PositionStatus.OPEN,
        nullable=False,
        index=True
    )

    # Entry
    entry_price: Mapped[float] = mapped_column(Float, nullable=False)
    position_size: Mapped[float] = mapped_column(Float, nullable=False)  # lots/shares
    entry_time: Mapped[datetime] = mapped_column(nullable=False, index=True)

    # Exit
    exit_price: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    exit_time: Mapped[Optional[datetime]] = mapped_column(nullable=True)

    # Risk management
    stop_loss: Mapped[float] = mapped_column(Float, nullable=False)
    take_profit: Mapped[float] = mapped_column(Float, nullable=False)
    trailing_stop: Mapped[Optional[float]] = mapped_column(Float, nullable=True)

    # P&L
    unrealized_pnl: Mapped[float] = mapped_column(Float, default=0.0, nullable=False)
    realized_pnl: Mapped[Optional[float]] = mapped_column(Float, nullable=True)

    # Commission and fees
    commission_paid: Mapped[float] = mapped_column(Float, default=0.0, nullable=False)

    # Relationships
    signal: Mapped[Optional["Signal"]] = relationship("Signal", back_populates="position")

    __table_args__ = (
        Index("ix_position_strategy_status", "strategy_name", "status"),
        Index("ix_position_symbol_status", "symbol", "status"),
    )

    def __repr__(self) -> str:
        return f"<Position {self.id} {self.strategy_name} {self.side.value} {self.symbol} {self.position_size} @ {self.entry_price}>"

    def calculate_pnl(self, current_price: float) -> float:
        """Calculate unrealized P&L."""
        if self.side == PositionSide.LONG:
            pnl = (current_price - self.entry_price) * self.position_size
        else:
            pnl = (self.entry_price - current_price) * self.position_size

        return pnl - self.commission_paid
```

Update `backend/app/models/__init__.py`:

```python
from app.models.base import Base, TimestampMixin
from app.models.user import User
from app.models.market_data import Candle, Symbol, EconomicEvent
from app.models.signal import Signal, SignalType, SignalStatus
from app.models.position import Position, PositionStatus, PositionSide

__all__ = [
    "Base",
    "TimestampMixin",
    "User",
    "Candle",
    "Symbol",
    "EconomicEvent",
    "Signal",
    "SignalType",
    "SignalStatus",
    "Position",
    "PositionStatus",
    "PositionSide",
]
```

### Step 2: Base Strategy Class

Create `backend/app/strategies/base_strategy.py`:

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from datetime import datetime
from app.models.market_data import Candle
from app.models.signal import Signal, SignalType, SignalStatus
from sqlalchemy.ext.asyncio import AsyncSession
import logging

logger = logging.getLogger(__name__)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    All strategies must implement:
    - analyze(): Generate signals from market data
    - get_name(): Return strategy name
    - get_default_config(): Return default configuration
    """

    def __init__(self, config: Dict[str, Any], db: AsyncSession):
        self.config = config
        self.db = db
        self.name = self.get_name()
        logger.info(f"Initialized strategy: {self.name}")

    @abstractmethod
    async def analyze(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> List[Signal]:
        """
        Analyze market data and generate trading signals.

        Args:
            symbol: Trading symbol
            candles: Historical OHLCV data (sorted oldest to newest)
            current_price: Current market price

        Returns:
            List of Signal objects (not yet committed to database)
        """
        pass

    @abstractmethod
    def get_name(self) -> str:
        """Return strategy name."""
        pass

    @abstractmethod
    def get_default_config(self) -> Dict[str, Any]:
        """Return default configuration parameters."""
        pass

    def validate_signal(self, signal: Signal) -> bool:
        """
        Validate signal meets minimum requirements.

        Override in subclass for custom validation.
        """
        # Minimum R:R ratio
        min_rr = self.config.get("min_risk_reward", 1.5)
        if signal.risk_reward_ratio < min_rr:
            logger.warning(f"Signal rejected: R:R {signal.risk_reward_ratio:.2f} < {min_rr}")
            return False

        # Stop loss must be set
        if signal.stop_loss <= 0:
            logger.warning("Signal rejected: Invalid stop loss")
            return False

        # Take profit must be set
        if signal.take_profit <= 0:
            logger.warning("Signal rejected: Invalid take profit")
            return False

        # Entry price must be between SL and TP
        if signal.signal_type == SignalType.LONG:
            if not (signal.stop_loss < signal.entry_price < signal.take_profit):
                logger.warning("Signal rejected: Invalid LONG price levels")
                return False
        else:
            if not (signal.take_profit < signal.entry_price < signal.stop_loss):
                logger.warning("Signal rejected: Invalid SHORT price levels")
                return False

        return True

    def calculate_position_size(
        self,
        account_balance: float,
        risk_percent: float,
        entry_price: float,
        stop_loss: float
    ) -> float:
        """
        Calculate position size based on risk parameters.

        Args:
            account_balance: Total account balance
            risk_percent: Risk percentage (e.g., 2.0 for 2%)
            entry_price: Entry price
            stop_loss: Stop loss price

        Returns:
            Position size in lots/shares
        """
        risk_amount = account_balance * (risk_percent / 100.0)
        risk_per_unit = abs(entry_price - stop_loss)

        if risk_per_unit == 0:
            return 0.0

        position_size = risk_amount / risk_per_unit
        return round(position_size, 2)

    async def save_signal(self, signal: Signal) -> Signal:
        """Save signal to database."""
        if self.validate_signal(signal):
            self.db.add(signal)
            await self.db.commit()
            await self.db.refresh(signal)
            logger.info(f"Signal saved: {signal}")
            return signal
        else:
            logger.warning(f"Signal validation failed: {signal}")
            raise ValueError("Signal validation failed")
```

### Step 3: Strategy Implementations

Create `backend/app/strategies/nbb_strategy.py`:

```python
from typing import List, Dict, Any
from datetime import datetime, timedelta
from app.strategies.base_strategy import BaseStrategy
from app.models.market_data import Candle
from app.models.signal import Signal, SignalType, SignalStatus
import logging

logger = logging.getLogger(__name__)


class NBBStrategy(BaseStrategy):
    """
    No Bullshit Breaker (NBB) Strategy

    Logic:
    - Identify supply/demand zones (swing highs/lows)
    - Wait for price to break zone with strong momentum
    - Enter on retest of broken zone
    - Stop loss beyond zone, TP at next zone
    """

    def get_name(self) -> str:
        return "NBB"

    def get_default_config(self) -> Dict[str, Any]:
        return {
            "timeframe": "1h",
            "zone_lookback": 20,  # candles to identify zones
            "breakout_threshold": 0.0015,  # 0.15% minimum breakout
            "retest_tolerance": 0.0005,  # 0.05% retest tolerance
            "min_risk_reward": 2.0,
            "risk_percent": 1.5,
            "confidence_threshold": 60.0,
        }

    async def analyze(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> List[Signal]:
        """Generate NBB signals based on zone breakouts."""
        if len(candles) < self.config["zone_lookback"] + 10:
            logger.warning(f"NBB: Insufficient data for {symbol}")
            return []

        signals = []

        # Identify supply/demand zones
        zones = self._identify_zones(candles)

        # Check for breakout and retest
        for zone in zones:
            signal = self._check_breakout_and_retest(
                symbol=symbol,
                candles=candles,
                current_price=current_price,
                zone=zone
            )
            if signal:
                signals.append(signal)

        return signals

    def _identify_zones(self, candles: List[Candle]) -> List[Dict[str, Any]]:
        """Identify supply and demand zones from swing points."""
        zones = []
        lookback = self.config["zone_lookback"]

        for i in range(lookback, len(candles) - lookback):
            # Demand zone (swing low)
            if self._is_swing_low(candles, i, lookback):
                zones.append({
                    "type": "demand",
                    "price": candles[i].low,
                    "index": i,
                    "high": candles[i].high,
                    "low": candles[i].low,
                })

            # Supply zone (swing high)
            if self._is_swing_high(candles, i, lookback):
                zones.append({
                    "type": "supply",
                    "price": candles[i].high,
                    "index": i,
                    "high": candles[i].high,
                    "low": candles[i].low,
                })

        return zones

    def _is_swing_low(self, candles: List[Candle], index: int, lookback: int) -> bool:
        """Check if candle at index is a swing low."""
        current_low = candles[index].low

        for i in range(index - lookback, index + lookback + 1):
            if i == index:
                continue
            if candles[i].low < current_low:
                return False

        return True

    def _is_swing_high(self, candles: List[Candle], index: int, lookback: int) -> bool:
        """Check if candle at index is a swing high."""
        current_high = candles[index].high

        for i in range(index - lookback, index + lookback + 1):
            if i == index:
                continue
            if candles[i].high > current_high:
                return False

        return True

    def _check_breakout_and_retest(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float,
        zone: Dict[str, Any]
    ) -> Signal | None:
        """Check if zone has been broken and retested."""
        breakout_threshold = self.config["breakout_threshold"]
        retest_tolerance = self.config["retest_tolerance"]

        zone_index = zone["index"]
        zone_price = zone["price"]

        # Check candles after zone for breakout
        for i in range(zone_index + 1, len(candles)):
            if zone["type"] == "demand":
                # Bullish breakout: price breaks above zone
                if candles[i].close > zone_price * (1 + breakout_threshold):
                    # Look for retest (price comes back to zone)
                    if abs(current_price - zone_price) / zone_price < retest_tolerance:
                        # Generate LONG signal
                        entry_price = current_price
                        stop_loss = zone["low"] * 0.999  # Just below zone
                        take_profit = entry_price + (entry_price - stop_loss) * 2.5

                        return Signal(
                            strategy_name=self.get_name(),
                            symbol=symbol,
                            signal_type=SignalType.LONG,
                            status=SignalStatus.PENDING,
                            entry_price=entry_price,
                            stop_loss=stop_loss,
                            take_profit=take_profit,
                            risk_percent=self.config["risk_percent"],
                            timeframe=self.config["timeframe"],
                            confidence=70.0,
                            reason=f"NBB: Demand zone breakout + retest at {zone_price:.5f}",
                            signal_time=datetime.utcnow(),
                            expiry_time=datetime.utcnow() + timedelta(hours=24)
                        )

            elif zone["type"] == "supply":
                # Bearish breakout: price breaks below zone
                if candles[i].close < zone_price * (1 - breakout_threshold):
                    # Look for retest
                    if abs(current_price - zone_price) / zone_price < retest_tolerance:
                        # Generate SHORT signal
                        entry_price = current_price
                        stop_loss = zone["high"] * 1.001  # Just above zone
                        take_profit = entry_price - (stop_loss - entry_price) * 2.5

                        return Signal(
                            strategy_name=self.get_name(),
                            symbol=symbol,
                            signal_type=SignalType.SHORT,
                            status=SignalStatus.PENDING,
                            entry_price=entry_price,
                            stop_loss=stop_loss,
                            take_profit=take_profit,
                            risk_percent=self.config["risk_percent"],
                            timeframe=self.config["timeframe"],
                            confidence=70.0,
                            reason=f"NBB: Supply zone breakout + retest at {zone_price:.5f}",
                            signal_time=datetime.utcnow(),
                            expiry_time=datetime.utcnow() + timedelta(hours=24)
                        )

        return None
```

Create `backend/app/strategies/jadecap_strategy.py`:

```python
from typing import List, Dict, Any
from datetime import datetime, timedelta
from app.strategies.base_strategy import BaseStrategy
from app.models.market_data import Candle
from app.models.signal import Signal, SignalType, SignalStatus
import logging

logger = logging.getLogger(__name__)


class JadeCapStrategy(BaseStrategy):
    """
    JadeCap Multi-Timeframe Trend Following Strategy

    Logic:
    - Identify trend on higher timeframe (4h/1day)
    - Wait for pullback to key moving average
    - Enter when lower timeframe (1h) confirms continuation
    - Ride trend with trailing stop
    """

    def get_name(self) -> str:
        return "JadeCap"

    def get_default_config(self) -> Dict[str, Any]:
        return {
            "htf": "4h",  # Higher timeframe
            "ltf": "1h",  # Lower timeframe
            "ema_fast": 20,
            "ema_slow": 50,
            "pullback_ema": 20,
            "min_risk_reward": 2.0,
            "risk_percent": 1.5,
            "trailing_stop_percent": 1.5,
        }

    async def analyze(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> List[Signal]:
        """Generate JadeCap signals based on multi-timeframe trend."""
        if len(candles) < self.config["ema_slow"] + 10:
            logger.warning(f"JadeCap: Insufficient data for {symbol}")
            return []

        signals = []

        # Calculate EMAs
        ema_fast = self._calculate_ema(candles, self.config["ema_fast"])
        ema_slow = self._calculate_ema(candles, self.config["ema_slow"])

        # Determine trend
        trend = self._determine_trend(ema_fast, ema_slow, candles)

        if trend == "bullish":
            # Look for pullback to EMA and continuation
            if self._is_bullish_pullback(candles, ema_fast, current_price):
                entry_price = current_price
                stop_loss = ema_slow[-1] * 0.995
                take_profit = entry_price + (entry_price - stop_loss) * 3.0

                signals.append(Signal(
                    strategy_name=self.get_name(),
                    symbol=symbol,
                    signal_type=SignalType.LONG,
                    status=SignalStatus.PENDING,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    risk_percent=self.config["risk_percent"],
                    timeframe=self.config["htf"],
                    confidence=75.0,
                    reason=f"JadeCap: Bullish trend + pullback to EMA{self.config['ema_fast']}",
                    signal_time=datetime.utcnow(),
                    expiry_time=datetime.utcnow() + timedelta(hours=48)
                ))

        elif trend == "bearish":
            if self._is_bearish_pullback(candles, ema_fast, current_price):
                entry_price = current_price
                stop_loss = ema_slow[-1] * 1.005
                take_profit = entry_price - (stop_loss - entry_price) * 3.0

                signals.append(Signal(
                    strategy_name=self.get_name(),
                    symbol=symbol,
                    signal_type=SignalType.SHORT,
                    status=SignalStatus.PENDING,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    risk_percent=self.config["risk_percent"],
                    timeframe=self.config["htf"],
                    confidence=75.0,
                    reason=f"JadeCap: Bearish trend + pullback to EMA{self.config['ema_fast']}",
                    signal_time=datetime.utcnow(),
                    expiry_time=datetime.utcnow() + timedelta(hours=48)
                ))

        return signals

    def _calculate_ema(self, candles: List[Candle], period: int) -> List[float]:
        """Calculate Exponential Moving Average."""
        prices = [c.close for c in candles]
        ema = []
        multiplier = 2 / (period + 1)

        # First EMA is SMA
        sma = sum(prices[:period]) / period
        ema.append(sma)

        # Calculate EMA for remaining prices
        for price in prices[period:]:
            ema_value = (price - ema[-1]) * multiplier + ema[-1]
            ema.append(ema_value)

        return ema

    def _determine_trend(
        self,
        ema_fast: List[float],
        ema_slow: List[float],
        candles: List[Candle]
    ) -> str:
        """Determine trend direction."""
        if len(ema_fast) < 5 or len(ema_slow) < 5:
            return "neutral"

        # Bullish: fast EMA above slow EMA and rising
        if ema_fast[-1] > ema_slow[-1] and ema_fast[-1] > ema_fast[-5]:
            return "bullish"

        # Bearish: fast EMA below slow EMA and falling
        if ema_fast[-1] < ema_slow[-1] and ema_fast[-1] < ema_fast[-5]:
            return "bearish"

        return "neutral"

    def _is_bullish_pullback(
        self,
        candles: List[Candle],
        ema_fast: List[float],
        current_price: float
    ) -> bool:
        """Check if price has pulled back to EMA in bullish trend."""
        if len(ema_fast) < 3:
            return False

        # Price should be near EMA (within 0.5%)
        ema_current = ema_fast[-1]
        if abs(current_price - ema_current) / ema_current > 0.005:
            return False

        # Recent candles should show bounce from EMA
        if candles[-1].close > candles[-2].close:
            return True

        return False

    def _is_bearish_pullback(
        self,
        candles: List[Candle],
        ema_fast: List[float],
        current_price: float
    ) -> bool:
        """Check if price has pulled back to EMA in bearish trend."""
        if len(ema_fast) < 3:
            return False

        ema_current = ema_fast[-1]
        if abs(current_price - ema_current) / ema_current > 0.005:
            return False

        if candles[-1].close < candles[-2].close:
            return True

        return False
```

Create `backend/app/strategies/fabio_strategy.py`:

```python
from typing import List, Dict, Any
from datetime import datetime, timedelta
from app.strategies.base_strategy import BaseStrategy
from app.models.market_data import Candle
from app.models.signal import Signal, SignalType, SignalStatus
import logging

logger = logging.getLogger(__name__)


class FabioStrategy(BaseStrategy):
    """
    Fabio Auction Market Theory (AMT) Strategy

    Logic:
    - Calculate Value Area (POC, VAH, VAL) from volume profile
    - Trade breakouts from value area
    - Enter when price returns to POC after breakout
    - Target previous high/low
    """

    def get_name(self) -> str:
        return "Fabio"

    def get_default_config(self) -> Dict[str, Any]:
        return {
            "timeframe": "1h",
            "value_area_percent": 70,  # 70% of volume
            "lookback_candles": 50,
            "min_risk_reward": 2.0,
            "risk_percent": 2.0,
        }

    async def analyze(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> List[Signal]:
        """Generate Fabio AMT signals."""
        lookback = self.config["lookback_candles"]

        if len(candles) < lookback:
            logger.warning(f"Fabio: Insufficient data for {symbol}")
            return []

        signals = []

        # Calculate value area
        value_area = self._calculate_value_area(candles[-lookback:])

        poc = value_area["poc"]
        vah = value_area["vah"]
        val = value_area["val"]

        # Check for breakout and retest
        if current_price > vah * 1.002:  # Above value area
            # Look for retest of POC from above
            if self._is_retest_from_above(candles[-10:], poc, current_price):
                entry_price = current_price
                stop_loss = val * 0.998
                take_profit = vah * 1.01

                signals.append(Signal(
                    strategy_name=self.get_name(),
                    symbol=symbol,
                    signal_type=SignalType.LONG,
                    status=SignalStatus.PENDING,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    risk_percent=self.config["risk_percent"],
                    timeframe=self.config["timeframe"],
                    confidence=80.0,
                    reason=f"Fabio AMT: Breakout above VA, retest POC {poc:.5f}",
                    signal_time=datetime.utcnow(),
                    expiry_time=datetime.utcnow() + timedelta(hours=24)
                ))

        elif current_price < val * 0.998:  # Below value area
            if self._is_retest_from_below(candles[-10:], poc, current_price):
                entry_price = current_price
                stop_loss = vah * 1.002
                take_profit = val * 0.99

                signals.append(Signal(
                    strategy_name=self.get_name(),
                    symbol=symbol,
                    signal_type=SignalType.SHORT,
                    status=SignalStatus.PENDING,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    risk_percent=self.config["risk_percent"],
                    timeframe=self.config["timeframe"],
                    confidence=80.0,
                    reason=f"Fabio AMT: Breakout below VA, retest POC {poc:.5f}",
                    signal_time=datetime.utcnow(),
                    expiry_time=datetime.utcnow() + timedelta(hours=24)
                ))

        return signals

    def _calculate_value_area(self, candles: List[Candle]) -> Dict[str, float]:
        """
        Calculate Point of Control (POC), Value Area High (VAH), Value Area Low (VAL).

        Simplified volume profile calculation.
        """
        # Create price levels with volume
        price_levels = {}

        for candle in candles:
            # Discretize prices into levels (round to 4 decimals)
            high_level = round(candle.high, 4)
            low_level = round(candle.low, 4)
            close_level = round(candle.close, 4)

            # Distribute volume across range
            num_levels = max(1, int((high_level - low_level) / 0.0001))
            volume_per_level = candle.volume / num_levels if num_levels > 0 else candle.volume

            price = low_level
            while price <= high_level:
                price_key = round(price, 4)
                if price_key not in price_levels:
                    price_levels[price_key] = 0
                price_levels[price_key] += volume_per_level
                price += 0.0001

        if not price_levels:
            # Fallback if no volume data
            avg_price = sum(c.close for c in candles) / len(candles)
            return {"poc": avg_price, "vah": avg_price * 1.005, "val": avg_price * 0.995}

        # Find POC (price level with highest volume)
        poc = max(price_levels.items(), key=lambda x: x[1])[0]

        # Calculate value area (70% of volume around POC)
        total_volume = sum(price_levels.values())
        target_volume = total_volume * (self.config["value_area_percent"] / 100.0)

        sorted_prices = sorted(price_levels.items(), key=lambda x: x[1], reverse=True)

        value_area_volume = 0
        value_area_prices = []

        for price, volume in sorted_prices:
            value_area_prices.append(price)
            value_area_volume += volume
            if value_area_volume >= target_volume:
                break

        vah = max(value_area_prices)
        val = min(value_area_prices)

        return {"poc": poc, "vah": vah, "val": val}

    def _is_retest_from_above(
        self,
        recent_candles: List[Candle],
        poc: float,
        current_price: float
    ) -> bool:
        """Check if price is retesting POC from above."""
        if len(recent_candles) < 2:
            return False

        # Price should be near POC (within 0.3%)
        if abs(current_price - poc) / poc > 0.003:
            return False

        # Recent candles should show move toward POC
        if recent_candles[-2].close > poc and current_price <= poc * 1.002:
            return True

        return False

    def _is_retest_from_below(
        self,
        recent_candles: List[Candle],
        poc: float,
        current_price: float
    ) -> bool:
        """Check if price is retesting POC from below."""
        if len(recent_candles) < 2:
            return False

        if abs(current_price - poc) / poc > 0.003:
            return False

        if recent_candles[-2].close < poc and current_price >= poc * 0.998:
            return True

        return False
```

Create `backend/app/strategies/tori_strategy.py`:

```python
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
from app.strategies.base_strategy import BaseStrategy
from app.models.market_data import Candle
from app.models.signal import Signal, SignalType, SignalStatus
import logging

logger = logging.getLogger(__name__)


class ToriStrategy(BaseStrategy):
    """
    Tori Trendline + Fibonacci Confluence Strategy

    Logic:
    - Draw trendlines from swing highs/lows
    - Calculate Fibonacci retracement levels (38.2%, 50%, 61.8%)
    - Enter when price bounces off trendline + Fib level
    - Target next Fib extension
    """

    def get_name(self) -> str:
        return "Tori"

    def get_default_config(self) -> Dict[str, Any]:
        return {
            "timeframe": "4h",
            "swing_lookback": 30,
            "fib_levels": [0.382, 0.5, 0.618],
            "confluence_tolerance": 0.002,  # 0.2% tolerance
            "min_risk_reward": 2.5,
            "risk_percent": 1.5,
        }

    async def analyze(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> List[Signal]:
        """Generate Tori signals based on trendline + Fib confluence."""
        lookback = self.config["swing_lookback"]

        if len(candles) < lookback + 10:
            logger.warning(f"Tori: Insufficient data for {symbol}")
            return []

        signals = []

        # Identify swing points
        swing_highs = self._find_swing_highs(candles, lookback)
        swing_lows = self._find_swing_lows(candles, lookback)

        # Calculate trendlines
        uptrend_line = self._calculate_trendline(swing_lows, candles)
        downtrend_line = self._calculate_trendline(swing_highs, candles)

        # Calculate Fibonacci levels
        fib_levels = self._calculate_fibonacci_levels(candles)

        # Check for confluence (trendline + Fib level)
        if uptrend_line and fib_levels:
            if self._is_confluence(current_price, uptrend_line, fib_levels["support"]):
                entry_price = current_price
                stop_loss = min(fib_levels["support"]) * 0.995
                take_profit = entry_price + (entry_price - stop_loss) * 3.0

                signals.append(Signal(
                    strategy_name=self.get_name(),
                    symbol=symbol,
                    signal_type=SignalType.LONG,
                    status=SignalStatus.PENDING,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    risk_percent=self.config["risk_percent"],
                    timeframe=self.config["timeframe"],
                    confidence=85.0,
                    reason=f"Tori: Uptrend + Fib confluence at {current_price:.5f}",
                    signal_time=datetime.utcnow(),
                    expiry_time=datetime.utcnow() + timedelta(hours=48)
                ))

        if downtrend_line and fib_levels:
            if self._is_confluence(current_price, downtrend_line, fib_levels["resistance"]):
                entry_price = current_price
                stop_loss = max(fib_levels["resistance"]) * 1.005
                take_profit = entry_price - (stop_loss - entry_price) * 3.0

                signals.append(Signal(
                    strategy_name=self.get_name(),
                    symbol=symbol,
                    signal_type=SignalType.SHORT,
                    status=SignalStatus.PENDING,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    risk_percent=self.config["risk_percent"],
                    timeframe=self.config["timeframe"],
                    confidence=85.0,
                    reason=f"Tori: Downtrend + Fib confluence at {current_price:.5f}",
                    signal_time=datetime.utcnow(),
                    expiry_time=datetime.utcnow() + timedelta(hours=48)
                ))

        return signals

    def _find_swing_highs(self, candles: List[Candle], lookback: int) -> List[Tuple[int, float]]:
        """Find swing high points (index, price)."""
        swing_highs = []

        for i in range(lookback, len(candles) - lookback):
            is_swing_high = True
            for j in range(i - lookback, i + lookback + 1):
                if j != i and candles[j].high >= candles[i].high:
                    is_swing_high = False
                    break

            if is_swing_high:
                swing_highs.append((i, candles[i].high))

        return swing_highs[-5:]  # Last 5 swing highs

    def _find_swing_lows(self, candles: List[Candle], lookback: int) -> List[Tuple[int, float]]:
        """Find swing low points (index, price)."""
        swing_lows = []

        for i in range(lookback, len(candles) - lookback):
            is_swing_low = True
            for j in range(i - lookback, i + lookback + 1):
                if j != i and candles[j].low <= candles[i].low:
                    is_swing_low = False
                    break

            if is_swing_low:
                swing_lows.append((i, candles[i].low))

        return swing_lows[-5:]  # Last 5 swing lows

    def _calculate_trendline(
        self,
        swing_points: List[Tuple[int, float]],
        candles: List[Candle]
    ) -> Optional[float]:
        """Calculate current trendline price (simplified linear regression)."""
        if len(swing_points) < 2:
            return None

        # Use last two swing points
        p1_idx, p1_price = swing_points[-2]
        p2_idx, p2_price = swing_points[-1]

        # Calculate slope
        slope = (p2_price - p1_price) / (p2_idx - p1_idx)

        # Project to current price
        current_idx = len(candles) - 1
        trendline_price = p2_price + slope * (current_idx - p2_idx)

        return trendline_price

    def _calculate_fibonacci_levels(self, candles: List[Candle]) -> Optional[Dict[str, List[float]]]:
        """Calculate Fibonacci retracement levels."""
        if len(candles) < 20:
            return None

        # Find recent high and low
        recent_high = max(c.high for c in candles[-50:])
        recent_low = min(c.low for c in candles[-50:])

        fib_range = recent_high - recent_low

        support_levels = []
        resistance_levels = []

        for level in self.config["fib_levels"]:
            fib_price = recent_low + fib_range * level
            support_levels.append(fib_price)

            fib_price_res = recent_high - fib_range * level
            resistance_levels.append(fib_price_res)

        return {
            "support": support_levels,
            "resistance": resistance_levels
        }

    def _is_confluence(
        self,
        current_price: float,
        trendline_price: float,
        fib_levels: List[float]
    ) -> bool:
        """Check if current price is at confluence of trendline and Fib level."""
        tolerance = self.config["confluence_tolerance"]

        # Check if price is near trendline
        if abs(current_price - trendline_price) / trendline_price > tolerance:
            return False

        # Check if price is near any Fib level
        for fib_level in fib_levels:
            if abs(current_price - fib_level) / fib_level < tolerance:
                return True

        return False
```

### Step 4: Strategy Manager

Create `backend/app/strategies/strategy_manager.py`:

```python
from typing import Dict, List, Type
from sqlalchemy.ext.asyncio import AsyncSession
from app.strategies.base_strategy import BaseStrategy
from app.strategies.nbb_strategy import NBBStrategy
from app.strategies.jadecap_strategy import JadeCapStrategy
from app.strategies.fabio_strategy import FabioStrategy
from app.strategies.tori_strategy import ToriStrategy
from app.models.signal import Signal
from app.models.market_data import Candle
import logging

logger = logging.getLogger(__name__)


class StrategyManager:
    """Manages all trading strategies and signal generation."""

    def __init__(self, db: AsyncSession):
        self.db = db
        self.strategies: Dict[str, BaseStrategy] = {}
        self._register_strategies()

    def _register_strategies(self):
        """Register all available strategies."""
        strategy_classes: List[Type[BaseStrategy]] = [
            NBBStrategy,
            JadeCapStrategy,
            FabioStrategy,
            ToriStrategy,
        ]

        for strategy_class in strategy_classes:
            strategy = strategy_class(
                config=strategy_class.get_default_config(strategy_class),
                db=self.db
            )
            self.strategies[strategy.get_name()] = strategy
            logger.info(f"Registered strategy: {strategy.get_name()}")

    def get_strategy(self, name: str) -> BaseStrategy:
        """Get strategy by name."""
        if name not in self.strategies:
            raise ValueError(f"Strategy '{name}' not found")
        return self.strategies[name]

    def list_strategies(self) -> List[str]:
        """List all registered strategy names."""
        return list(self.strategies.keys())

    async def run_strategy(
        self,
        strategy_name: str,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> List[Signal]:
        """Run a specific strategy and return signals."""
        strategy = self.get_strategy(strategy_name)

        logger.info(f"Running strategy '{strategy_name}' for {symbol}")
        signals = await strategy.analyze(
            symbol=symbol,
            candles=candles,
            current_price=current_price
        )

        logger.info(f"Strategy '{strategy_name}' generated {len(signals)} signals for {symbol}")
        return signals

    async def run_all_strategies(
        self,
        symbol: str,
        candles: List[Candle],
        current_price: float
    ) -> Dict[str, List[Signal]]:
        """Run all strategies and return signals grouped by strategy."""
        all_signals = {}

        for strategy_name in self.strategies.keys():
            signals = await self.run_strategy(
                strategy_name=strategy_name,
                symbol=symbol,
                candles=candles,
                current_price=current_price
            )
            all_signals[strategy_name] = signals

        return all_signals
```

### Step 5: Database Migration

```bash
cd backend
DATABASE_URL="sqlite+aiosqlite:///./flowrex_dev.db" python -m alembic revision --autogenerate -m "add_signals_and_positions"
```

Run migration:
```bash
DATABASE_URL="sqlite+aiosqlite:///./flowrex_dev.db" python -m alembic upgrade head
```

### Step 6: API Routes

Create `backend/app/api/v1/strategy_routes.py`:

```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime, timedelta
from typing import List
from pydantic import BaseModel
from app.database import get_db
from app.data.data_service import DataService
from app.data.twelvedata_client import TwelveDataClient
from app.strategies.strategy_manager import StrategyManager
from app.models.signal import Signal, SignalStatus
from sqlalchemy import select, and_
import logging

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/strategies", tags=["strategies"])


class SignalResponse(BaseModel):
    id: int
    strategy_name: str
    symbol: str
    signal_type: str
    status: str
    entry_price: float
    stop_loss: float
    take_profit: float
    risk_percent: float
    confidence: float
    reason: str | None
    signal_time: datetime
    risk_reward_ratio: float

    class Config:
        from_attributes = True


class StrategyListResponse(BaseModel):
    strategies: List[str]


@router.get("/", response_model=StrategyListResponse)
async def list_strategies(db: AsyncSession = Depends(get_db)):
    """List all available strategies."""
    manager = StrategyManager(db=db)
    strategies = manager.list_strategies()
    return {"strategies": strategies}


@router.post("/analyze/{symbol}")
async def analyze_symbol(
    symbol: str,
    strategy_name: str | None = None,
    interval: str = Query("1h"),
    db: AsyncSession = Depends(get_db)
):
    """
    Run strategy analysis on a symbol.

    If strategy_name is provided, runs only that strategy.
    Otherwise, runs all strategies.
    """
    async with TwelveDataClient() as client:
        data_service = DataService(db=db, client=client)

        # Get historical candles
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=90)

        candles = await data_service.get_candles(
            symbol=symbol,
            interval=interval,
            start_date=start_date,
            end_date=end_date
        )

        if not candles:
            # Fetch if missing
            await data_service.fetch_and_store_candles(
                symbol=symbol,
                interval=interval,
                start_date=start_date,
                end_date=end_date
            )
            candles = await data_service.get_candles(
                symbol=symbol,
                interval=interval,
                start_date=start_date,
                end_date=end_date
            )

        if not candles:
            raise HTTPException(status_code=404, detail=f"No data available for {symbol}")

        # Get current price
        quote = await client.get_quote(symbol)
        current_price = quote["price"]

        # Run strategies
        manager = StrategyManager(db=db)

        if strategy_name:
            signals = await manager.run_strategy(
                strategy_name=strategy_name,
                symbol=symbol,
                candles=candles,
                current_price=current_price
            )
            result = {strategy_name: [SignalResponse.model_validate(s) for s in signals]}
        else:
            all_signals = await manager.run_all_strategies(
                symbol=symbol,
                candles=candles,
                current_price=current_price
            )
            result = {
                name: [SignalResponse.model_validate(s) for s in sigs]
                for name, sigs in all_signals.items()
            }

        return result


@router.get("/signals", response_model=List[SignalResponse])
async def get_signals(
    strategy_name: str | None = None,
    symbol: str | None = None,
    status: SignalStatus | None = None,
    limit: int = Query(50, ge=1, le=500),
    db: AsyncSession = Depends(get_db)
):
    """Get signals with optional filters."""
    stmt = select(Signal)

    filters = []
    if strategy_name:
        filters.append(Signal.strategy_name == strategy_name)
    if symbol:
        filters.append(Signal.symbol == symbol)
    if status:
        filters.append(Signal.status == status)

    if filters:
        stmt = stmt.where(and_(*filters))

    stmt = stmt.order_by(Signal.signal_time.desc()).limit(limit)

    result = await db.execute(stmt)
    signals = result.scalars().all()

    return [SignalResponse.model_validate(s) for s in signals]


@router.post("/signals/{signal_id}/cancel")
async def cancel_signal(signal_id: int, db: AsyncSession = Depends(get_db)):
    """Cancel a pending signal."""
    stmt = select(Signal).where(Signal.id == signal_id)
    result = await db.execute(stmt)
    signal = result.scalar_one_or_none()

    if not signal:
        raise HTTPException(status_code=404, detail="Signal not found")

    if signal.status != SignalStatus.PENDING:
        raise HTTPException(status_code=400, detail=f"Cannot cancel signal with status {signal.status}")

    signal.status = SignalStatus.CANCELLED
    await db.commit()

    return {"message": f"Signal {signal_id} cancelled"}
```

Register routes in `backend/app/main.py`:

```python
from app.api.v1 import auth_routes, data_routes, strategy_routes

app.include_router(strategy_routes.router, prefix="/api/v1")
```

### Step 7: Tests

Create `backend/tests/unit/test_strategies.py`:

```python
import pytest
from app.strategies.nbb_strategy import NBBStrategy
from app.strategies.jadecap_strategy import JadeCapStrategy
from app.strategies.fabio_strategy import FabioStrategy
from app.strategies.tori_strategy import ToriStrategy
from app.models.market_data import Candle
from datetime import datetime, timedelta


@pytest.mark.asyncio
class TestNBBStrategy:
    async def test_strategy_initialization(self, async_db_session):
        strategy = NBBStrategy(
            config=NBBStrategy.get_default_config(NBBStrategy),
            db=async_db_session
        )
        assert strategy.get_name() == "NBB"
        assert strategy.config["zone_lookback"] == 20

    async def test_analyze_insufficient_data(self, async_db_session):
        strategy = NBBStrategy(
            config=NBBStrategy.get_default_config(NBBStrategy),
            db=async_db_session
        )

        # Only 10 candles (needs at least 30)
        candles = [
            Candle(
                symbol="EURUSD",
                interval="1h",
                timestamp=datetime.utcnow() - timedelta(hours=i),
                open=1.1000,
                high=1.1010,
                low=1.0990,
                close=1.1005,
                volume=1000
            )
            for i in range(10)
        ]

        signals = await strategy.analyze("EURUSD", candles, 1.1005)
        assert len(signals) == 0


@pytest.mark.asyncio
class TestJadeCapStrategy:
    async def test_ema_calculation(self, async_db_session):
        strategy = JadeCapStrategy(
            config=JadeCapStrategy.get_default_config(JadeCapStrategy),
            db=async_db_session
        )

        candles = [
            Candle(
                symbol="EURUSD",
                interval="4h",
                timestamp=datetime.utcnow() - timedelta(hours=i * 4),
                open=1.1000 + i * 0.0001,
                high=1.1010 + i * 0.0001,
                low=1.0990 + i * 0.0001,
                close=1.1005 + i * 0.0001,
                volume=1000
            )
            for i in range(60)
        ]

        ema = strategy._calculate_ema(candles, 20)
        assert len(ema) > 0
        assert all(isinstance(val, float) for val in ema)


@pytest.mark.asyncio
class TestStrategyManager:
    async def test_register_all_strategies(self, async_db_session):
        from app.strategies.strategy_manager import StrategyManager

        manager = StrategyManager(db=async_db_session)
        strategies = manager.list_strategies()

        assert "NBB" in strategies
        assert "JadeCap" in strategies
        assert "Fabio" in strategies
        assert "Tori" in strategies
        assert len(strategies) == 4
```

Run tests:
```bash
cd backend
DATABASE_URL="sqlite+aiosqlite:///./flowrex_dev.db" python -m pytest tests/unit/test_strategies.py -v
```

### Step 8: Manual Testing

Start server:
```bash
cd backend
DATABASE_URL="sqlite+aiosqlite:///./flowrex_dev.db" python -m uvicorn app.main:app --reload
```

Test endpoints:

**List strategies:**
```bash
curl "http://localhost:8000/api/v1/strategies/"
```

**Analyze symbol with all strategies:**
```bash
curl -X POST "http://localhost:8000/api/v1/strategies/analyze/EURUSD?interval=1h"
```

**Analyze with specific strategy:**
```bash
curl -X POST "http://localhost:8000/api/v1/strategies/analyze/EURUSD?strategy_name=NBB&interval=1h"
```

**Get all signals:**
```bash
curl "http://localhost:8000/api/v1/strategies/signals?limit=20"
```

## Validation Checklist

Before proceeding to Prompt 05, verify:

- [ ] Signal and Position models created
- [ ] Database migration applied successfully
- [ ] `signals` and `positions` tables exist with proper indexes
- [ ] BaseStrategy abstract class implemented
- [ ] NBB strategy implemented with zone detection
- [ ] JadeCap strategy implemented with EMA trend following
- [ ] Fabio strategy implemented with Value Area calculation
- [ ] Tori strategy implemented with trendline + Fibonacci
- [ ] StrategyManager registers all 4 strategies
- [ ] All strategies return Signal objects (not saved yet)
- [ ] Signal validation checks R:R ratio, SL/TP validity
- [ ] API route `/strategies/` lists all strategies
- [ ] API route `/strategies/analyze/{symbol}` runs strategies
- [ ] API route `/strategies/signals` retrieves signals
- [ ] All unit tests pass
- [ ] Can list strategies via API
- [ ] Can analyze EURUSD and receive signals
- [ ] Signals include entry, SL, TP, confidence, reason
- [ ] CROSSCHECK.md validation for Prompt 04 completed

## Hard Stop Criteria

**DO NOT PROCEED to Prompt 05 unless:**

1. ✅ Database migration runs without errors
2. ✅ All 4 strategies (NBB, JadeCap, Fabio, Tori) are implemented
3. ✅ All pytest tests pass (0 failures, 0 errors)
4. ✅ StrategyManager successfully registers all strategies
5. ✅ Can run analysis via API and receive valid signals
6. ✅ Signals have proper entry/SL/TP levels
7. ✅ Signal validation rejects invalid signals (R:R < threshold)
8. ✅ All API endpoints respond with 200 status
9. ✅ Strategies generate signals based on their respective logic
10. ✅ CROSSCHECK.md section for Prompt 04 fully validated

If any criterion fails, **HALT** and fix before continuing.

---

**Completion Criteria:**
- Strategy engine fully operational with 4 complete strategies
- Signal generation and validation working
- API provides strategy analysis capabilities
- All tests pass
- System ready for Backtest Engine (Prompt 05)
